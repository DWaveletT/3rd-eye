---
create_time: 1694076276
update_time: 1694076276
title: 【笔记】交互题的实现
board: 1
tag:
- 2
---

## 编译的过程

考虑一个典型的 $\text{c++}$ 程序编译过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/1l9wdo7s.png)

### 预处理

我们把所有带井号的语句全部称为宏。预处理器会根据这些宏对源代码进行预处理。那些 $\verb!#define!$ 语句、$\verb!#ifdef!$、$\verb!#else!$ 语句、$\verb!#endif!$ 语句，包括于 $\verb!#include!$ 语句，都是喂给预编译器用的。

预处理器碰到不是宏的语句（开头不是井号的），会直接输出；否则对于那些宏，预处理器会按照一定的约定执行操作。比如说，$\verb!#ifdef!$ 语句就是告诉预处理器，如果满足某某条件就往下面读，否则跳转到 $\verb!#else!$ 或者跳转到 $\verb!#elseif!$ 或者跳转到 $\verb!#endif!$。像 $\verb!#include!$ 语句，本质就是指示编译器要查找一下指定的文件，递归地去预处理那些文件。

此外，注释也会被预处理器忽略。

预处理器最后输出的是完成了预处理后的源代码，里面应该不包含任何的宏和注释了。

比如我们在文件 $\verb!header.h!$ 里这样写：

```cpp
// header.h
#ifndef __HEAD
#define __HEAD

int a /*arg a*/ = 114;
int b /*arg b*/ = 514;

char name[] = "senpai";
// Senpai, daisuki

#endif
```

在文件 $\verb!test.cpp!$ 里这样写：

```cpp
// test.cpp
#include "header.h"
#include "header.h"
#include "header.h"

int fun(){
    return a < b ? a : b;
}
```

在控制台里执行命令：

> $\verb!g++ test.cpp -E -o test.i!$

输出到的 $\verb!test.i!$ 里面大概长这样：

```cpp
# 0 "test.cpp"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "test.cpp"
# 1 "header.h" 1



int a = 114;
int b = 514;

char name[] = "senpai";
# 2 "test.cpp" 2



int fun(){
    return a < b ? a : b;
}
```

开头那些带井号的东西都是喂给编译器用的。似乎可以忽略。其他的东西就是预处理完的程序实际包含的。

这里我们特地没有调用什么系统库，因为通常系统库里面还会有嵌套调用，并且这些库文件巨长，放在这里很占篇幅……有兴趣的同学可以试试预编译一下引用了万能头的程序。顺带也能解释为啥编译带万能头的文件为啥这么慢。

### 编译 & 汇编

在讲编译之前稍微介绍一下机器语言和汇编语言。

计算机硬件（比如中央处理器 CPU）运行时只会根据输入进来的二进制 $01$ 串执行命令。这些命令都非常简单，由大量简单的命令组合在一起实现很多比较复杂的工作。

一些非常简单的命令：

- 赋值操作：将放在寄存器 $a$ 里面的值赋给寄存器 $b$；
- 相加操作：将放在寄存器 $a$ 里面的值，和寄存器 $b$ 里的值相加，结果给寄存器 $c$。

这些指令会被编码成二进制 $01$ 串。比如说，一个长度为 $16$ 的指令，可能前 $8$ 位告诉 CPU 这个指令是啥（赋值操作、相加操作，或者别的什么操作），后面几位指定操作的寄存器的编号。

但因为全是 $0$ 和 $1$，很不方便阅读，并且在不同的 CPU 上它们的编码可能是不一样的。因此诞生了汇编语言。比如说，上述的相加操作，我们用一个这样的人眼可以轻易辨别的写法：

- ${{\tt ADD}\ a\ b\ c}$

（因为笔者太菜没学过编译原理，所以上述内容具体是怎么实现的我是一点也不知道）。

一块 CPU 支持的简单指令们组成了一个集合，称作指令集。比如 SSE 指令集，SSE2 指令集，x86 指令集之类的，都可以看作一系列汇编指令的集合。CPU 支持指令集 SSE2 就是说，在汇编语言里写成的 SSE2 里的指令，这块 CPU 都可以执行。

编译器要做的事情就是把具有一定复杂程度的高级语言给翻译成更加简单的汇编语言。

市面上的这些指令集都相当于是规范。两个不同的高级语言，假定它们生成的汇编语言所用的指令集是相同的，那生成的汇编文件长得应该差不多。对于同一份汇编文件，在不同硬件环境下生成的机器语言可能是不一样的（因为 CPU 本身约定的机器码可能是不同的），但是它们的功能应该都相同。

仍然是拿上面的例子，我们尝试把 $\verb!a.i!$ 给编译了：

> $\verb!g++ a.i -S -o a.s!$

生成了这样一个老长的 $\verb!a.s!$。这个就是汇编文件。

```cpp
	.file	"test.cpp"
	.text
	.globl	a
	.data
	.align 4
a:
	.long	114
	.globl	b
	.align 4
b:
	.long	514
	.globl	name
name:
	.ascii "senpai\0"
	.text
	.globl	_Z3funv
	.def	_Z3funv;	.scl	2;	.type	32;	.endef
	.seh_proc	_Z3funv
_Z3funv:
.LFB0:
	pushq	%rbp
	.seh_pushreg	%rbp
	movq	%rsp, %rbp
	.seh_setframe	%rbp, 0
	.seh_endprologue
	movl	a(%rip), %edx
	movl	b(%rip), %eax
	cmpl	%eax, %edx
	jge	.L2
	movl	a(%rip), %eax
	jmp	.L4
.L2:
	movl	b(%rip), %eax
.L4:
	popq	%rbp
	ret
	.seh_endproc
	.ident	"GCC: (GNU) 11.2.0"

```

可以简单观察一下这个程序，前面给出了 $a$ 和 $b$ 的描述（全局变量，初值为 $114$ 和 $514$，占用的内存对齐到了 $4$ 个字节），接着描述了函数 $\verb!fun!$（汇编文件里，它的名字叫做 $\verb!_Z3funv!$，加上了一个前缀和一个后缀。后文会提到为啥这东西要改名）。在 $\verb!_Z3funv!$ 这一段，我们可以清楚地看到 $\verb!movl!$ 语句把 $a$ 和 $b$ 分别装到了寄存器 $\verb!%edx!$ 和 $\verb!%eax!$ 里面，然后用 $\verb!cmpl!$ 语句和 $\verb!jge!$ 语句根据这俩寄存器的大小关系选择要跳转到哪里去。

当然汇编代码还是不太适合人眼阅读，但是很适合汇编器去阅读。这玩意儿喂给汇编器就能生成目标文件。

目标文件就是标准的二进制文件了。你可以在命令行里面执行以下语句：

> $\verb!g++ test.s -c -o test.o!$

得到文件名为 $\verb!test.o!$ 的目标文件。

### 链接

一份代码可能会调用一些函数。这些函数的实现可能不在这个代码或者它引用的头文件里。换言之，经过预处理、编译、汇编生成的这个目标文件里，有一些函数你只知道它有定义，但是不知道它的具体实现是啥。它的具体实现可能在别的某个地方。

很多 STL 函数的代码实现都在头文件里。

但有些更底层的函数，比如说，$\texttt{scanf}$ 和 $\texttt{printf}$，最深层到底调用了哪些系统函数、怎么调用的，都是黑盒。并且你不太可能把它们直接写在头文件里（尤其是它们可能与系统相关，调用的函数是操作系统提供的）。

比如说，文件 a 声明了一个函数 $\verb!fun!$，在某个地方调用了它，但是没有具体实现；而文件 b **同样**声明了这个函数 $\verb!fun!$，给出了具体实现。那么将文件 a 和 b 链接在一起，a 文件调用 $\verb!fun!$ 的时候就会自动跳转到文件 b 里对应的实现。

不过可执行文件还有另外一个要求，就是要有主函数。运行可执行文件本质上就是让操作系统去调用那个主函数。

所以，链接的这些文件里，应该恰好有一个给出了主函数的实现。这样编译出来的文件操作系统才知道从哪运行。

不过链接也分成两种：**静态链接**和**动态链接**。

#### 静态链接

在编译的时候，我们就知道函数 $\verb!fun!$ 的实现放在了文件 b 里面。那我们生成可执行文件的时候，就把文件 a 和文件 b 直接放在一起链接，链接器会自动寻找 $\verb!fun!$ 的实现，并且把它交给文件 a 里面调用的地方。

#### 动态链接

有些函数在编译的时候你都不知道它在哪里实现了。但是它在运行的时候系统会提供一些动态库，那些函数的实现就在动态库里面。可执行程序就会从动态库里调取相应的函数实现。

不过这一步就归操作系统管了。

某些游戏的开发环境可能是有动态库的，所以开发者可以在自己环境下进行测试。分发给用户的时候没有分发动态库，然后就发现游戏运行不起来，点击运行的时候会跳出弹窗说缺啥啥啥库。此时需要从某个地方下载对应的库才能正常运行。

## 函数交互

### 典型实现过程

首先描述一下一个典型的函数交互题的过程：

- 出题人准备好文件 $\verb!grader.h!$，里面有函数 $\verb!solve!$ 的声明。
- 出题人准备好文件 $\verb!grader.cpp!$，其中引用头文件 $\verb!grader.h!$。$\verb!grader.cpp!$ 里面有主函数的实现。主函数在运行过程中会直接或者间接地调用 $\verb!solve!$ 函数。
- 选手提交文件 $\verb!test.cpp!$，里面包含头文件 $\verb!grader.h!$。$\verb!grader.h!$ 里面有函数 $\verb!solve!$ 的声明。选手按照题目要求，在自己提交的代码里实现了函数 $\verb!solve!$，但是提交上去的代码并没有实现主函数。


阅读完上面的内容，你可能已经能猜出来接下来怎么实现函数交互了。

评测机首先分别编译 $\verb!test.cpp!$ 和 $\verb!grader.cpp!$，分别生成目标文件 $\verb!test.o!$ 和 $\verb!grader.o!$。两个文件的内容如下：

- $\verb!test.o!$ 里，声明了 $\verb!solve!$，实现了 $\verb!solve!$；
- $\verb!grader.o!$ 里，声明了 $\verb!solve!$，实现了主函数 $\verb!main!$，同时 $\verb!main!$ 调用 $\verb!solve!$ 函数。

我们将这两个文件做链接，得到可执行文件。接着运行该可执行文件并进行结果的比较。

接着我们来分析一下 $\verb!grader.h!$ 的作用。它其实做的事情就是让 $\verb!test.cpp!$ 和 $\verb!grader.cpp!$ 共享 $\verb!solve!$ 的声明，这样就可以避免链接的时候两个目标文件函数表里面 $\verb!solve!$ 对不上导致 $\verb!grader.o!$ 没法调用 $\verb!test.o!$ 里的 $\verb!solve!$ 函数。

### 不同标准的支持

考虑这样一个特殊的情形：

- $\verb!grader.cpp!$ 由于使用了比较新的语法，需要在 $14$ 以上标准编译；
- $\verb!test.cpp!$ 由于某些特别原因（选手自己指定以 $98$ 标准提交，或者代码本身就是不能在 $14$ 以上标准编译。这种情况是客观存在的，比如某些函数因为比较危险/不太好用被更新的标准废除了）。

按道理来说，作为一个 OJ，

### 不同语言的支持

现在将问题上升到一个明显困难的地步：如果我们希望让函数交互支持其他语言，应该怎么办？

